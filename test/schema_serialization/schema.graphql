#*************************** DIRECTIVES ***************************

directive @gqServiceName(name: String) on FIELD_DEFINITION
directive @gqSkipOnServer(mapTo: String) on FIELD_DEFINITION|OBJECT
directive @gqSkipOnClient on FIELD_DEFINITION|OBJECT
directive @gqDecorators(value: [String!]!, applyOnClient: Boolean! = false, applyOnServer: Boolean! = true) on FIELD_DEFINITION|OBJECT|INTERFACE
directive @gqEqualsHashcode(fields: [String!]!) on OBJECT
directive @Document(
    value: String!,
    gqAnnotation: Boolean = true
    gqFQCN: String = "@org.springframework.data.mongodb.core.mapping.Document"
    gqOnClient: Boolean = false
    gqOnServer: Boolean = true
) on OBJECT


directive @FieldNameConstants(
    gqAnnotation: Boolean = true
    gqFQCN: String = "@lombok.experimental.FieldNameConstants"
    gqOnClient: Boolean = false
    gqOnServer: Boolean = true

) on OBJECT | INPUT_OBJECT | INTERFACE
directive @JsonProperty(
    value: String!
    gqAnnotation: Boolean = true
    gqFQCN: String = "@com.fasterxml.jackson.annotation.JsonProperty"
    gqOnClient: Boolean = false
    gqOnServer: Boolean = true

) on OBJECT | INPUT_OBJECT | INTERFACE | FIELD_DEFINITION


directive @Query(
    value: String!
    gqAnnotation: Boolean = true
    gqFQCN: String = "@org.springframework.data.mongodb.repository.Query"
    gqOnClient: Boolean = false
    gqOnServer: Boolean = true

) on FIELD_DEFINITION

directive @gqQuery(
    value: String
    count: Boolean
    exists: Boolean
    delete: Boolean
    fields: String
    sort: String
    gqFQCN: String = "org.springframework.data.mongodb.repository.Query"
) on FIELD_DEFINITION

directive @gqRepository(
    gqType: String!
    gqIdType: String!
    gqFQCN: String = "org.springframework.data.mongodb.repository.MongoRepository"
) on INTERFACE

directive @gqExternal(
    gqFQCN: String
) on OBJECT|INPUT_OBJECT
#*************************** REPOS ******************************
enum BannedType {
    CLINIC
}
interface BanRepository  @gqRepository(gqIdType: "String", gqType: "Ban") {

    findByBannerIdAndType(bannerId: ID!, type: BannedType): [Ban!]! @gqQuery(value: "{ 'address.zipCode': ?0, 'phoneNumber': ?1 }")
}
interface CouncilRepository  @gqRepository(gqIdType: "String", gqType: "Council") {
    findByTitleIdAndActive(titleId: String, active: Boolean): [Council!]!
    findByIdAndTitleIdAndActive(id: ID!, titleId: String!, active: Boolean): Council
}
interface MissionRepository  @gqRepository(gqIdType: "String", gqType: "Mission") {
    _:Int
}

interface FriendshipRepository  @gqRepository(gqIdType: "String", gqType: "Friendship") {
    _:Int
}


interface MissionApplicationRepository  @gqRepository(gqIdType: "String", gqType: "MissionApplication") {
    deleteAllByMissionId(missionId: ID!): String
}



interface DentilynxUserRepository  @gqRepository(gqIdType: "String", gqType: "DentilynxUser") {
    existsByEmail(email: String!): Boolean!
    existsByUsername(username: String!): Boolean!
    findByUsername(username: String!): DentilynxUser
}

interface JobTitleRepository  @gqRepository(gqIdType: "String", gqType: "JobTitle") {
    findByActive(active: Boolean!): [JobTitle!]!
    findByIdAndActive(id: ID!, active: Boolean!): JobTitle
}

interface EducationRepository  @gqRepository(gqIdType: "String", gqType: "Education") {
    findAllByUserId(userId: String):[Education!]!
}

interface ExperienceRepository  @gqRepository(gqIdType: "String", gqType: "Experience") {
    findAllByUserId(userId: String):[Experience!]!
}

interface StoryRepository  @gqRepository(gqIdType: "String", gqType: "Story") {
    findByActive(active: Boolean!):[Story!]!
}

interface UserTokenRepository  @gqRepository(gqIdType: "String", gqType: "UserToken") {
    _: Int!
}

interface NotifRepository  @gqRepository(gqIdType: "String", gqType: "Notif") {
    countByOwnerIdAndRead(ownerId: ID!, read: Boolean!): Long!
    findByOwnerIdOrderByCreationDateDesc(ownerId: ID!, pageable: Pageable): [Notif!]!
}

input Pageable @gqExternal(gqFQCN: "org.springframework.data.domain.Pageable") {
    _:Int
}

interface FavoriteRepository  @gqRepository(gqIdType: "String", gqType: "Favorite") {
    findByOwnerIdAndType(ownerId: ID!, type: FavoriteType!):[Favorite!]!
}

interface CertificationRepository @gqRepository(gqIdType: "String", gqType: "Certification") {
    findAllByUserId(userId: ID!): [Certification!]!
}

interface ClinicRepository @gqRepository(gqIdType: "String", gqType: "Clinic") {
    findByZipCodeAndPhoneNumber( zipCode: String,  phoneNumber: String): [Clinic!]! @Query(value: "{ 'address.zipCode': ?0, 'phoneNumber': ?1 }")
}


#*************************** SCALAR ******************************
scalar Long @gqSkipOnClient
#*************************** INTERFACE ***************************
interface BasicEntity  {
    id: ID! @gqDecorators(value: ["@org.springframework.data.annotation.Id"])
    creationDate: Long! @gqDecorators(value: ["@org.springframework.data.annotation.CreatedDate"])
    lastUpdate: Long! @gqDecorators(value: ["@org.springframework.data.annotation.LastModifiedDate"])
    createdBy: String @gqDecorators(value: ["@org.springframework.data.annotation.CreatedBy"])
    lastModifiedBy: String @gqDecorators(value: ["@org.springframework.data.annotation.LastModifiedBy"])
}

interface UserBase implements BasicEntity {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    email: String
    firstName: String!
    lastName: String!
    gender: Gender
    roles: [String!]!
}
#*************************** QUERY ***************************
type UserToken implements BasicEntity @FieldNameConstants @Document(value: "tokens") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    tokens: [String!]!
}
type Ban implements BasicEntity @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    bannerId: String!
    bannedId: String!
    type: BannedType!
}

type Query {
    getMaxUploadSize: UploadConfig!
    getUsers(info: PagingInfo!, params: UserSearchParam!): [DentilynxUser!]!
    countUsers(params: UserSearchParam!): Long! @gqServiceName(name: "DentilynxUserService")
    getUserById(userId: String!): DentilynxUser!
    getUnreadNotifCount: Long! @gqServiceName(name: "NotifService")
    getNotifs(info: PagingInfo!): [Notif!]!
    ### stripe
    getPaymentMethods: [PaymentMethodDTO!]! @gqServiceName(name: "StripeService")
    createPaymentIntent(input: PaymentIntentInput!, missionId: String!): PaymentIntentResult! @gqServiceName(name: "StripeService")

    #### clinics
    getMyClinics: [Clinic!]!
    findClinicsByZipCodeAndPhoneNumber(zipCode: String!, phoneNumber: String!): [Clinic!]!

    ### stories
    getActiveStories: [Story!]!
    getAllStories: [Story!]!
    validatePhoneNumber(phoneNumber: String!, region: String!): String @gqServiceName(name: "PhoneService")

    findAllTitles: [JobTitle!]!
    findActiveTitles: [JobTitle!]!

    findAllCouncils: [Council!]!
    findActiveCouncils(titleId: String!): [Council!]!
    allLanguages: [SpokenLanguage!]! @gqServiceName(name: "RefService")
    skills: [String!]! @gqServiceName(name: "RefService")
    software: [String!]! @gqServiceName(name: "RefService")
    paymentMethods: [PaymentMethod!]! @gqServiceName(name: "RefService")
    radiography: [String!]! @gqServiceName(name: "RefService")
    ultrasound: [String!]! @gqServiceName(name: "RefService")

    listEducations: [Education!]!
    listExperiences: [Experience!]!
    listCertifications: [Certification!]!


    getMyClinicsAll(info: PagingInfo!): [ClinicFavBan!]! @gqServiceName(name: "ClinicService")
    getMyClinicsFavorites(info: PagingInfo!): [ClinicFavBan!]! @gqServiceName(name: "ClinicService")
    getMyClinicsBanned(info: PagingInfo!): [ClinicFavBan!]! @gqServiceName(name: "ClinicService")

    getCalendarStats(startDate: DateInput!, endDate: DateInput!, clinicId: String): [DayStats!]! @gqServiceName(name: "MissionService")
    ## missions
    missionAll: [Mission!]!

    findMissions(input: MissionSearchParams!, pagingInfo: PagingInfo!): [MissionAppCount!]!  @gqServiceName(name: "MissionService")
    getMissionForPro(input: ProMissionSearchParams!, pagingInfo: PagingInfo!): [MissionWithApplication!]! @gqServiceName(name: "MissionService")
    getMissionById(missionId: String!): Mission!
    getApplications(missionId: String!, pagingInfo: PagingInfo!): [MissionApplication!]!


    ## friendships
    getFriendShips(status: FriendshipStatus!, info: PagingInfo!): [Friendship!]!
    searchByPhoneNumber(phoneNumber: String): [UserFriendShip!]! @gqServiceName(name: "DentilynxUserService")
    getSentFriendships(info: PagingInfo!): [Friendship!]!
    getReceivedFriendships(info: PagingInfo!): [Friendship!]!


}



#*************************** MUTATION ***************************
type Mutation {
    login(phoneNumber: String!, code: String!, clinicOwner: Boolean!): TokenUser! @gqServiceName(name: "LoginService")
    refreshToken(token: String!): TokenUser! @gqServiceName(name: "LoginService")
    saveToken(token: String!): String @gqServiceName(name: "TokenService")
    removeToken(token: String!): String @gqServiceName(name: "TokenService")


    ### places
    getPlaces(req: String!, lang: String!): PlacesResult! @gqServiceName(name: "PlacesService")
    geoCodePlacesByCoordinates(coordinates: CoordinatesInput!): String! @gqServiceName(name: "PlacesService")
    geoCodePlacesById(placeId: String!): Coordinates! @gqServiceName(name: "PlacesService")
    ### places
    updatePhoneNumber(token: String!): DentilynxUser!


    apply(input: ApplicationInput!): Mission!
    acceptApplication(appId: String!): Mission!
    cancelApplication(appId: String!): Mission!
    declineApplication(appId: String!): Mission!

    markAsRead(notifId: String!, read: Boolean!): Notif!
    deleteNotif(notifId: String!): String @gqServiceName(name: "NotifService")
    broadcast(jobTitle: String!, body: String): String @gqServiceName(name: "NotifService")


    createClinic(input: ClinicInput!): Clinic!
    createStory(input: StoryInput!): Story!
    createTitle(input: TitleInput!): JobTitle!
    createCouncil(input: CouncilInput!): Council!
    completeInfo(input: CompleteInfoInput!): DentilynxUser!
    setCaregiverAddress(addressInput: AddressInput!, geoPointInput: GeoPointInput!): DentilynxUser! @gqServiceName(name: "ProfileService")
    updateTitle(input: TitleInfoInput!): DentilynxUser!
    importClinics: String @gqServiceName(name: "ClinicService")
    updateLegal(allowedToWorkInCanada: Boolean, councilId: String): DentilynxUser! @gqServiceName(name: "ProfileService")
    updateSkills(skills: [String!]): DentilynxUser! @gqServiceName(name: "ProfileService")
    updateSoftware(software: [String!]): DentilynxUser! @gqServiceName(name: "ProfileService")
    updateLanguages(languages: [SpokenLanguageInput!]): DentilynxUser! @gqServiceName(name: "ProfileService")
    updatePresentationLetter(presentationLetter: String!): DentilynxUser! @gqServiceName(name: "ProfileService")
    updateHourlyRate(rate: Float!): DentilynxUser! @gqServiceName(name: "ProfileService")
    setPaymentMethod(input: PaymentMethodInput!): DentilynxUser! @gqServiceName(name: "ProfileService")
    setFilters(input: MyFiltersInput!): DentilynxUser! @gqServiceName(name: "ProfileService")

    addEducation(input: EducationInput!): Education!
    deleteEducation(id: String!): Boolean! @gqServiceName(name: "EducationService")
    addExperience(input: ExperienceInput!): Experience!
    deleteExperience(id: String!): Boolean! @gqServiceName(name: "ExperienceService")

    addCertification(input: CertificationInput!): Certification!
    deleteCertification(id: String!): Boolean! @gqServiceName(name: "CertificationService")


    banClinic(clinicId: String!): Ban! @gqServiceName(name: "BanService")
    unbanClinic(clinicId: String!): Boolean! @gqServiceName(name: "BanService")

    addClinicToFavorites(clinicId: String!): Favorite! @gqServiceName(name: "FavoriteService")
    removeFromFavorites(clinicId: String!): Boolean! @gqServiceName(name: "FavoriteService")
    setClinicFilter(input: ClinicFilterInput!, clinicId: String!): Clinic!

    setLanguages(clinicId: String!, languages: [SpokenLanguageInput!]!): Clinic!
    setRadiography(clinicId: String!, radiography: [String!]!): Clinic!
    setUltrasound(clinicId: String!, ultrasound: [String!]!): Clinic!
    setSpecialities(clinicId: String!, specialities: [String!]!): Clinic!
    setSoftware(clinicId: String!, software: [String!]!): Clinic!
    setDentalRecord(clinicId: String!, dentalRecord: DentalRecord!): Clinic!
    setParking(clinicId: String!, parking: Parking!): Clinic!
    setBillingContact(clinicId: String!, input: BillingContactInput!): Clinic!
    setOtherInformation(clinicId: String!, input: String!): Clinic!

    ## missions

    createMission(input: MissionInput!): Mission!
    cancelMission(missionId: String!): Mission! @gqServiceName(name: "MissionService")
    deleteMyAccount: String @gqServiceName(name: "ProfileService")

    rateProfessional(missionId: String!, input: ProRateInput!): Mission!
    rateClinic(missionId: String!, input: ClinicRateInput!): Mission!
    completeMission(missionId: String!, rateInput: ProRateInput!, realDayInfoInput: DayInfoInput!, realBreakLength: Int!): Mission!
    completeMissionByClinic(missionId: String!, rateInput: ClinicRateInput!, realDayInfoInput: DayInfoInput!, realBreakLength: Int!, payed: Boolean!, paymentMethod: PaymentMethodInput!, amount: Float): Mission!

    ## friendships

    requestFriendShip(friendId: String!): Friendship!
    acceptFriendShip(friendShipId: String!): Friendship!
    declineFriendShip(friendShipId: String!): Friendship!
    deleteFriendship(friendShipId: String!): Friendship

}
#*************************** SUBSCRIPTION ***************************

#*************************** TYPE ***************************

type UserFriendShip @gqSkipOnServer(mapTo: "DentilynxUser")  @FieldNameConstants {
    user: DentilynxUser!
    isFriend: Boolean!
    alreadySent: Boolean!
}

type ProRate  @FieldNameConstants {
    timeRespected: Float!
    communication: Float!
    professionalism: Float!
    global: Float!
    comment: String
}

type ClinicRate  @FieldNameConstants {
    punctuality: Float!
    competence: Float!
    professionalism: Float!
    global: Float!
    comment: String
}

type DayStats  @FieldNameConstants {
    date: String!
    formatPattern: String!
    missionStats: MissionStats!
    scheduleStats: ScheduleStats!
    clinicCalendarStats: ClinicCalendarStats!
}

type ClinicCalendarStats  @FieldNameConstants {
    fullTime: Boolean!
    missionCount: Int!
    multiDteMissionCount: Int!
    applied: Boolean!
    confirmed: Boolean!
    canceled: Boolean!
    attentionRequired: Boolean!
    completed: Boolean!
}

type MissionStats  @FieldNameConstants {
    availableCount: Int!
    availablePartTimeCount: Int!
    appliedCount: Int!
}

type ScheduleStats  @FieldNameConstants {
    mainJob: Boolean! #Bottom
    attentionRequired: Boolean! #center
    eventsCount: Int! #bottom
    missionConfirmedCount: Int! #right
    missionCanceledCount: Int! #right
    missionCompletedCount: Int! #right
    notAvailable: Boolean! #bottom

}


type MyFilters  @FieldNameConstants {
    notifyOnNewMission: Boolean!
    notifyIfKnowSoftware: Boolean!
    selectedDistance: MissionDistanceFilter!
    showBelowRateMissions: Boolean!
    autoAccept: Boolean!
    ultimatum: Boolean!
    contactInfo: ContactInfoVisibility!
    defaultProProfile: Boolean!
}
type Certification implements BasicEntity  @FieldNameConstants @Document(value: "certifications") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String!
    name: String!
    organization: String!
    neverExpire: Boolean!
    issueDate: Long!
    expirationDate: Long
    credentialId: String!
}
type Education implements BasicEntity @FieldNameConstants @Document(value: "education") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String!
    schoolName: String!
    grade: String!
    fieldOfStudy: String!
    currentlyStudying: Boolean!
    startDate: Long!
    endDate: Long
    location: AddressLocation!
}

type Experience implements BasicEntity @FieldNameConstants @Document(value: "experience") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String!
    title: String!
    type: ExperienceType!
    company: String!
    currentlyWorking: Boolean!
    startDate: Long!
    endDate: Long
    location: AddressLocation!
}

type AddressLocation {
    address: Address!
    location: GeoPoint!
}

type PaymentMethod {
    id: String!
    name: String!
}

input PaymentMethodInput {
    id: String!
    name: String!
}


####################### STRIPE ##########################



type PaymentMethodDTO {
    id: String!
    last4: String!
    type: String!
    customerId: String!
    paymentMethod: String!
    brand: String!
}

type PaymentIntentResult {
    clientSecret: String!
    status: String!
    paymentIntentId: String!
}


####################### END ##########################



####################### OPENID USERS ##########################
type ResponseToken {
    accessToken: String!  @JsonProperty(value:  "access_token")
    expiresIn: Int! @JsonProperty(value:  "expires_in")
    refreshExpiresIn: Int! @JsonProperty(value:  "refresh_expires_in")
    refreshToken: String! @JsonProperty(value:  "refresh_token")
    tokenType: String! @JsonProperty(value:  "token_type")
    notBeforePolicy: Int! @JsonProperty(value:  "not-before-policy")
    sessionState: String! @JsonProperty(value:  "session_state")
    scope: String! @JsonProperty(value:  "scope")
}

type TokenUser {
    token: ResponseToken!
    user: DentilynxUser!
}

type MissionWithApplication @gqSkipOnServer(mapTo: "Mission") {
    mission: Mission!
    application: MissionApplication
}

type MissionAppCount @gqSkipOnServer(mapTo: "Mission"){
    mission: Mission!
    applicationCount: Int!
    acceptedPro: DentilynxUser
}


type User {
    name: String!
    email: String
    roles: [String!]!
}

type RealmAccess {
    roles: [String!]!
}

type ResourceAccess {
    account: Account!
}

type Account {
    roles: [String!]!
}

####################### END OPENID USERS ######################

type CaregiverInfo @FieldNameConstants {
    jobTitle: JobTitle
    council: CouncilInfo
    missionInfo: MissionInfo
    schoolInfo: SchoolInfo
    allowedToWorkInCanada: Boolean
    memberOfCouncil: String
    skills: [String!]!
    software: [String!]!
    presentationLetter: String
    paymentMethod: PaymentMethod
    myFilters: MyFilters!
}

type MissionInfo @FieldNameConstants {
    hourlyRate: Float!
    lookingForFullTime: Boolean!
    acceptsEveningShifts: Boolean!
    days: [JobDay!]!
}

type CouncilInfo {
    council: Council!
    memberSinceYear: Int!
    licenseNumber: String!
}

type CaregiverAddressInfo @FieldNameConstants {
    address: Address
    geoPoint: GeoPoint

}

type SpokenLanguage @gqEqualsHashcode(fields: ["code"]) {
    code: String!
    name: String!
    nativeName: String!
}

type Council implements BasicEntity @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    name: String!
    active: Boolean!
    titleId: String @gqSkipOnClient

}
type SchoolInfo {
    name: String!
    graduationYear: Int!
}

type JobTitle implements BasicEntity @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    name: String!
    nameFr: String
    active: Boolean!
    requiresCouncil:  Boolean!
    requiresSchool:  Boolean!
    canLookForFullTimeJob:  Boolean!
}


type UploadConfig {
    size: Long!
    text: String!
}

type Story implements BasicEntity @FieldNameConstants @Document(value: "story") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    type: StoryType!
    active: Boolean!
    data: String!

}

input StoryInput {
    id: String
    type: StoryType!
    active: Boolean!
    data: String!
}

type DentilynxUser implements UserBase & BasicEntity @FieldNameConstants @Document(value: "DentlynxUser") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    email: String
    firstName: String!
    lastName: String!
    middleName: String
    gender: Gender
    roles: [String!]!
    photoUrl: String
    phoneNumber: String
    phoneVerified: Boolean!
    caregiverInfo: CaregiverInfo
    addressInfo: CaregiverAddressInfo
    spokenLanguages: [SpokenLanguage!]!
    stripeCustomers: [String!]! @gqSkipOnClient
    username: String @gqSkipOnClient
}

type CaregiverInfoRecord {
    userInfo: UserInfo!
    title: JobTitle!
}

type UserInfo  @FieldNameConstants {
    id: String!
    firstName: String!
    lastName: String!
    middleName: String
    selfie: String
}



type Mission implements BasicEntity  @FieldNameConstants @Document(value: "mission") {
    id: ID!
    titleInfo: TitleInfo!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    createdByUserInfo: UserInfo!
    proInfo: UserInfo
    date: DayInfo!
    realDayInfo: DayInfo
    breakLength: Int!
    realBreakLength: Int
    description: String!
    hourlyRate: Float!
    type: MissionType!
    clinic: Clinic! @gqSkipOnServer
    clinicId: String @gqSkipOnClient
    status: MissionStatus!
    cancelDate: Long
    proRateTheClinic: ProRate
    clinicRateThePro: ClinicRate
    realDayInfoClinic: DayInfo
    realBreakLengthClinic: Int
    amount: Float
    paymentMethod: PaymentMethod
    payed: Boolean
    appliedUserIds: [String!] @gqSkipOnClient
}

type TitleInfo @FieldNameConstants {
    id: String!
    name: String!
    nameFr: String!
}



type DayInfo @FieldNameConstants {
    date: Long!
    startTime: Time!
    endTime: Time!
}

type Time {
    hour: Int!
    minute: Int!
}

type ClinicManager @FieldNameConstants {
    manager: UserInfo!
}

type ClinicFavBan @gqSkipOnServer(mapTo: "Clinic"){
    clinic: Clinic!
    banned: Boolean!
    favorite: Boolean!
}

type Clinic implements BasicEntity  @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    phoneNumber: String!
    name: String!
    address: Address!
    logoUrl: String
    status: ClinicCreationStatus!
    rejectionRaison: String
    managers: [ClinicManager!]!
    filter: ClinicFilter!
    software: [String!]!
    specialities: [String!]!
    languages: [SpokenLanguage!]!
    parking: Parking
    billingContact: BillingContact
    dentalRecord: DentalRecord
    radiography: [String!]!
    ultrasound: [String!]!
    otherInformation: String
    geoPoint: GeoPoint
    administrativeRegion: String
}

type BillingContact {
    firstName: String!
    lastName: String!
    email: String!
    ccEmail: String
    ccOtherEmail: String
}

type ClinicFilter {
    contactHighRateCandidatesIfNoAvailable: Boolean!
    autoAcceptApplicants: AutoAcceptApplicants!
    notifyOnNewApplication: Boolean!
    showClinicContactsOnPublicProfile: ShowClinicContactsOnPublicProfile!
    myProfileAsDefault: Boolean!
}


type GeoPoint {
    coordinates: [Float!]!
}

type ReceiverInfo {
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String!
    email: String!
}

type Coordinates {
    longitude: Float!
    latitude: Float!
    address: Address
    localTime: Long
    serverTime: Long
    provider: String
}

type Address  @FieldNameConstants {
    road: String
    street: String
    suite: String
    city: String
    state: String
    zipCode: String
    country: String
    formattedAddress: String!
}

type MonthlyMissionSummary {
    monthIndex: Int!
    statusCounts: [MissionStatusCount!]!
}

type MissionStatusCount {
    status: MissionStatus!
    count: Int!
}

type MissionApplication implements BasicEntity  @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    proId: ID! @gqSkipOnClient
    missionId: String!
    status: ApplicationStatus!
    message: String
    acceptedAt: Long
    missionDate: Long @gqSkipOnClient
    user: DentilynxUser! @gqSkipOnServer

}

type Notif implements BasicEntity @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    title: String!
    body: String!
    read: Boolean!
    imageUrl: String
    ownsMission: Boolean!
    missionId: String
    ownerId: String! @gqSkipOnClient
}

############ google places #######################

interface Cache implements BasicEntity {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String
}

type DirectionsCache implements Cache & BasicEntity @FieldNameConstants @Document(value: "DirectionsCache") {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String

    result: DirectionResult
    withTrafficInfo: Boolean
    lang: String
    departureTime: Long
    origin: GeoPoint
    destination: GeoPoint
}

type DistanceMatrixCache  implements Cache & BasicEntity @FieldNameConstants  {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String

    response: DistanceMatrixResponse
    origins: String
    destinations: String
    time: Long
    withoutTraffic: Boolean
    origin: GeoPoint
    destination: GeoPoint
}

type GeocodeCache  implements Cache & BasicEntity @FieldNameConstants  {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String
    response: GeocodeResponse
    result: GeocodeResult
}

type PlacesCache implements Cache & BasicEntity @FieldNameConstants  {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    userId: String

    result: PlacesResult
    query: String
    lang: String
}

type CacheHit implements BasicEntity @gqSkipOnClient @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    cacheId: String
    isHit: Boolean
    userId: String
    cacheType: String
    type: String
}

type AddressComponent {
    longName: String @JsonProperty(value:  "long_name")
    shortName: String
    types: [String]
}

type Bounds {
    northeast: Coords
    southwest: Coords
}

type Coords {
    lng: Float
    lat: Float
}

type DirectionResult {
    geocodedWaypoints: [GeocodedWaypoint] @JsonProperty(value:  "geocoded_waypoints")
    status: DirectionResultStatus
    routes: [Route]
}

enum DirectionResultStatus {
    OK
    NOT_FOUND
    ZERO_RESULTS
    MAX_WAYPOINTS_EXCEEDED
    MAX_ROUTE_LENGTH_EXCEEDED
    INVALID_REQUEST
    OVER_DAILY_LIMIT
    OVER_QUERY_LIMIT
    REQUEST_DENIED
    UNKNOWN_ERROR
}

type DistanceDurationValue {
    distance: Float
    duration: Float
    durationInTraffic: Float
}

type DistanceMatrixRequest {
    origins: [Coordinates]
    destinations: [Coordinates]
}

type DistanceMatrixResponse {
    status: ResponseStatus
    originalAddresses: [String] @JsonProperty(value:  "origin_addresses")
    destinationAddresses: [String] @JsonProperty(value:  "destination_addresses")
    errorMessage: String @JsonProperty(value:  "error_message")
    elements: [Element]
    rows: [Row]
}

type Element {
    status: ElementStatus
    duration: TextValue
    distance: TextValue
    durationInTraffic: TextValue @JsonProperty(value:  "duration_in_traffic")
}

enum ElementStatus {
    OK
    NOT_FOUND
    ZERO_RESULTS
    MAX_ROUTE_LENGTH_EXCEEDED
}

type TextValue {
    distance: Boolean!
    text: String
    value: Long
}

type Fare {
    distance: Boolean
    text: String
    value: Long
    currency: String
}

type GeocodedWaypoint {
    status: GeocodedWaypointStatus @JsonProperty(value:  "geocoder_status")
    placeId: String @JsonProperty(value:  "place_id")
    types: [String]
}

enum GeocodedWaypointStatus {
    OK
    ZERO_RESULTS
}

type GeocodeResponse @FieldNameConstants{
    results: [GeocodeResult]
    status: ResponseStatus
}

type GeocodeResult @FieldNameConstants{
    addressComponents: [AddressComponent] @JsonProperty(value:  "address_components")
    formattedAddress: String @JsonProperty(value:  "formatted_address")
    geometry: Geometry
    placeId: String @JsonProperty(value:  "place_id")
    types: [String]
}

type Geometry @FieldNameConstants{
    location: Coords
    locationType: String @JsonProperty(value:  "location_type")
    viewport: Viewport
}

type Leg {
    distance: TextValue
    duration: TextValue
    startAddress: String @JsonProperty(value:  "start_address")
    endAddress: String @JsonProperty(value:  "end_address")
    startLocation: Coords @JsonProperty(value:  "start_location")
    endLocation: Coords @JsonProperty(value:  "end_location")
    steps: [Step]
}

type MatchedSubstring {
    length: Int!
    offset: Int!
}


type Polyline {
    points: String
}

type Prediction {
    description: String
    id: String
    matchedSubStrings: [MatchedSubstring] @JsonProperty(value:  "matched_substrings")
    placeId: String @JsonProperty(value:  "place_id")
    reference: String
    structuredFormatting: StructuredFormatting @JsonProperty(value:  "structured_formatting")
    terms: [Term]
    types: [String]
}

enum ResponseStatus {
    OK
    INVALID_REQUEST
    MAX_ELEMENTS_EXCEEDED
    OVER_QUERY_LIMIT
    REQUEST_DENIED
    UNKNOWN_ERROR
    ZERO_RESULTS
}

type Route {
    copyrights: String
    bounds: Bounds
    legs: [Leg]
    overviewPolyline: Polyline @JsonProperty(value:  "overview_polyline")
    summary: String
}

type Row {
    elements: [Element]
}

type Step {
    distance: TextValue
    duration: TextValue
    startLocation: Coords @JsonProperty(value:  "start_location")
    endLocation: Coords @JsonProperty(value:  "end_location")
    polyline: Polyline
    HtmlInstructions: String @JsonProperty(value:  "html_instructions")
    travelMode: String @JsonProperty(value:  "travel_mode")
}





type Viewport {
    northeast: Coords
    southwest: Coords
}

type PlacesResult {
    predictions: [Prediction!]!
    status: ResponseStatus!
}





type Term {
    offset: Int!
    value: String
    length: Int!
}

type StructuredFormatting {
    mainText: String!
    secondaryText: String
    mainTextMatchedSubstrings: [Term!]
}

type Friendship implements BasicEntity  @FieldNameConstants {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String
    status: FriendshipStatus
    ownerId: String!
    friendId: String! @gqSkipOnClient
    friend: DentilynxUser! @gqSkipOnServer
}

type Favorite implements BasicEntity @FieldNameConstants  {
    id: ID!
    creationDate: Long!
    lastUpdate: Long!
    createdBy: String
    lastModifiedBy: String

    ownerId: String!
    favoriteId: String!
    type: FavoriteType!
}

##### end google places ##########

#*************************** INPUT ***************************

input ProRateInput {
    timeRespected: Float!
    communication: Float!
    professionalism: Float!
    global: Float!
    comment: String
}

input ClinicRateInput {
    punctuality: Float!
    competence: Float!
    professionalism: Float!
    global: Float!
    comment: String
}

input MyFiltersInput {
    notifyOnNewMission: Boolean!
    notifyIfKnowSoftware: Boolean!
    selectedDistance: MissionDistanceFilter!
    showBelowRateMissions: Boolean!
    autoAccept: Boolean!
    ultimatum: Boolean!
    contactInfo: ContactInfoVisibility!
    defaultProProfile: Boolean!
}
input CertificationInput {
    id: String
    name: String!
    organization: String!
    neverExpire: Boolean!
    issueDate: DateInput!
    expirationDate: DateInput
    credentialId: String!
}

input EducationInput {
    id: String
    schoolName: String!
    grade: String!
    fieldOfStudy: String!
    currentlyStudying: Boolean!
    startDate: DateInput!
    endDate: DateInput
    location: AddressLocationInput!
}

input ExperienceInput {
    id: String
    title: String!
    type: ExperienceType!
    company: String!
    currentlyWorking: Boolean!
    startDate: DateInput!
    endDate: DateInput
    location: AddressLocationInput!
}



input AddressLocationInput {
    address: AddressInput!
    location: GeoPointInput!
}

input SchoolInfoInput {
    name: String!
    graduationYear: Int!
}
input TitleInfoInput {
    titleId: String!
    councilInfoInput: CouncilInfoInput
    missionInfoInput: MissionInfoInput
    schoolInfoInput: SchoolInfoInput
}
input CouncilInfoInput {
    councilId: String!
    memberSinceYear: Int!
    licenseNumber: String!
}
input MissionInfoInput {
    hourlyRate: Float
    lookingForFullTime: Boolean!
    acceptsEveningShifts: Boolean!
    days: [JobDay!]!
}
input CompleteInfoInput {
    firstName: String!
    lastName: String!
    email: String!
    spokenLanguages: [SpokenLanguageInput!]!
}

input SpokenLanguageInput {
    code: String!
    name: String!
    nativeName: String!
}

input GeoPointInput {
    lat: Float!
    lng: Float!
}

input CoordinatesInput {
    lat: Float!
    lng: Float!
}

input MissionInput {
    id: String
    days: [DayInfoInput!]!
    breakLength: Int!
    description: String!
    clinicId: String!
    type: MissionType!
    hourlyRate: Float!
    titleId: String!
}

input DayInfoInput {
    date: DateInput!
    startTime: TimeInput!
    endTime: TimeInput!
}


input TimeInput {
    hour: Int!
    minute: Int!
}


enum MissionType {
    FULL_TIME, REPLACEMENT
}

input ReceiverInfoInput {
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String!
    email: String
}

input UserInput {
    id: ID
    personalInfoInput: PersonalInfoInput!
    credentials: UserCredentialsInput
    username: String
}

input UserCredentialsInput {
    email: String!
    password: String!
}

input CredentialsInput {
    username: String!
    password: String!
    roles: [String!]!
}

input PersonalInfoInput {
    firstName: String!
    lastName: String!
    middleName: String
    dateOfBirth: Long!
    gender: Gender!
    phoneNumber: String
}

input PagingInfo {
    page: Int!
    size: Int!
}

input PasswordChange {
    old: String!
    current: String!
}

input UserSearchParam {
    firstName: String
    lastName: String
    sortField: String
    sortASC: Boolean
}

input MissionSearchParams {
    clinicId: String
    creatorId: String
    proId: String
    status: MissionStatus
    sortField: String
    sortASC: Boolean!
    startDate: DateInput
    endDate: DateInput
}

input ProMissionSearchParams {
    clinicId: String
    status: MissionStatus
    sortField: String
    sortASC: Boolean!
    startDate: DateInput
    endDate: DateInput
    appliedTo: Boolean
    hired: Boolean!
}


input ApplicationInput {
    missionId: String!
}

input CardInput {
    nameOnCard: String!
    cardName: String!
    makeDefault: Boolean!
    address: BillingAddressInput!
    paymentMethodId: String!
}

input BillingAddressInput {
    firstName: String!
    lastName: String!
    line1: String!
    line2: String
    city: String!
    state: String!
    zip: String!
    country: String!
}

input PaymentIntentInput {
    amount: Int!
    currency: String!
    customerId: String!
    paymentMethod: String!
}

input ClinicInput {
    id: String
    name: String!
    phoneNumber: String!
    address: AddressInput!
    geoPoint: GeoPointInput!
    logoUrl: String
}

input BillingContactInput {
    firstName: String!
    lastName: String!
    email: String!
    ccEmail: String
    ccOtherEmail: String
}

input AddressInput {
    road: String
    suite: String
    street: String!
    city: String!
    state: String!
    zipCode: String!
    country: String!
    formattedAddress: String!
}

input CouncilInput {
    id: ID
    name: String!
    active: Boolean!
    titleId: String!
}

input TitleInput {
    id: ID
    name: String!
    nameFr: String
    active: Boolean!
    requiresCouncil:  Boolean!
    requiresSchool:  Boolean!
    canLookForFullTimeJob:  Boolean!
}

input ClinicFilterInput {
    contactHighRateCandidatesIfNoAvailable: Boolean!
    autoAcceptApplicants: AutoAcceptApplicants!
    notifyOnNewApplication: Boolean!
    showClinicContactsOnPublicProfile: ShowClinicContactsOnPublicProfile!
    myProfileAsDefault: Boolean!
}

input DateInput {
    millis: Long!
    offsetSecs: Long!
}
#*************************** ENUMS ***************************

enum Gender {
    MAN
    WOMAN
}

enum MissionStatus {
    DRAFT, PUBLISHED, ACCEPTED, AWAIT_PAYMENT, CANCELED, DONE
}



enum ApplicationStatus {
    NEW, DECLINED, CANCELED, ACCEPTED, AUTO_CANCELED
}

enum StoryType {
    TEXT, IMAGE, VIDEO
}

enum JobDay {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}
enum ClinicCreationStatus {
    PENDING, VALID, REJECTED
}

enum ExperienceType {
    PERMANENT_FULL_TIME, PERMANENT_PART_TIME, CONTACT_FULL_TIME, CONTACT_PART_TIME
}

enum MissionDistanceFilter {
    FIVE_KMS
    TEN_KMS
    TWENTY_KMS
}

enum ContactInfoVisibility {
    SHOW
    HIDE
}

enum ShowClinicContactsOnPublicProfile {
    HIDE, MY_CANDIDATES, ALL
}

enum AutoAcceptApplicants {
    NO, FAVORITES, PREVIOUS, ALL
}

enum Parking {
    FREE, PAID, ON_STREET, PUBLIC, NO_PARKING
}

enum DentalRecord {
    DIGITAL, PAPER
}

enum FriendshipStatus {
    NEW, ACCEPTED
}

enum FavoriteType {
    CLINIC
}